--- qtbase/src/widgets/widgets/qdockarealayout.cpp.orig	2019-11-08 10:57:07.000000000 -0500
+++ qtbase/src/widgets/widgets/qdockarealayout.cpp	2019-12-01 12:06:05.000000000 -0500
@@ -228,7 +228,7 @@
 static const int zero = 0;
 
 QDockAreaLayoutInfo::QDockAreaLayoutInfo()
-    : sep(&zero), dockPos(QInternal::LeftDock), o(Qt::Horizontal), mainWindow(0)
+    : restoredSizeHint(0,0), sep(&zero), dockPos(QInternal::LeftDock), o(Qt::Horizontal), mainWindow(0)
 #if QT_CONFIG(tabbar)
     , tabbed(false), tabBar(0), tabBarShape(QTabBar::RoundedSouth)
 #endif
@@ -238,7 +238,7 @@
 QDockAreaLayoutInfo::QDockAreaLayoutInfo(const int *_sep, QInternal::DockPosition _dockPos,
                                             Qt::Orientation _o, int tbshape,
                                             QMainWindow *window)
-    : sep(_sep), dockPos(_dockPos), o(_o), mainWindow(window)
+    : restoredSizeHint(0,0), sep(_sep), dockPos(_dockPos), o(_o), mainWindow(window)
 #if QT_CONFIG(tabbar)
     , tabbed(false), tabBar(0), tabBarShape(static_cast<QTabBar::Shape>(tbshape))
 #endif
@@ -409,6 +409,9 @@
     if (isEmpty())
         return QSize(0, 0);
 
+    if (!restoredSizeHint.isNull())
+        return restoredSizeHint;
+
     int a = 0, b = 0;
     int min_perp = 0;
     int max_perp = QWIDGETSIZE_MAX;
@@ -2365,6 +2368,7 @@
         stream >> size;
         if (!testing) {
             docks[pos].rect = QRect(QPoint(0, 0), size);
+            docks[pos].restoredSizeHint = size;
         }
         if (!docks[pos].restoreState(stream, dockwidgets, testing)) {
             stream.setStatus(QDataStream::ReadCorruptData);
@@ -2642,6 +2646,23 @@
 
 static inline int qMax(int i1, int i2, int i3) { return qMax(i1, qMax(i2, i3)); }
 
+static QSize sizeHintForDock(QDockAreaLayoutInfo &dock)
+{
+    QSize size_hint = dock.size();
+    if (!dock.restoredSizeHint.isNull()) {
+        const QList<QDockAreaLayoutItem> item_list = dock.item_list;
+        for (int i = 0; i < item_list.size(); ++i) {
+            const QDockAreaLayoutItem &item = item_list.at(i);
+            QLayoutItem *w = item.widgetItem;
+            if (!item.skip() && w != 0 && !w->widget()->isHidden() && !w->widget()->isWindow()) {
+                size_hint = dock.restoredSizeHint;
+                break;
+            }
+        }
+    }
+    return size_hint;
+}
+
 void QDockAreaLayout::getGrid(QVector<QLayoutStruct> *_ver_struct_list,
                                 QVector<QLayoutStruct> *_hor_struct_list)
 {
@@ -2667,28 +2688,28 @@
     if (!docks[QInternal::BottomDock].isEmpty())
         center_rect.setBottom(rect.bottom() - docks[QInternal::BottomDock].rect.height() - sep);
 
-    QSize left_hint = docks[QInternal::LeftDock].size();
+    QSize left_hint = sizeHintForDock(docks[QInternal::LeftDock]);
     if (left_hint.isNull() || fallbackToSizeHints)
         left_hint = docks[QInternal::LeftDock].sizeHint();
     QSize left_min = docks[QInternal::LeftDock].minimumSize();
     QSize left_max = docks[QInternal::LeftDock].maximumSize();
     left_hint = left_hint.boundedTo(left_max).expandedTo(left_min);
 
-    QSize right_hint = docks[QInternal::RightDock].size();
+    QSize right_hint = sizeHintForDock(docks[QInternal::RightDock]);
     if (right_hint.isNull() || fallbackToSizeHints)
         right_hint = docks[QInternal::RightDock].sizeHint();
     QSize right_min = docks[QInternal::RightDock].minimumSize();
     QSize right_max = docks[QInternal::RightDock].maximumSize();
     right_hint = right_hint.boundedTo(right_max).expandedTo(right_min);
 
-    QSize top_hint = docks[QInternal::TopDock].size();
+    QSize top_hint = sizeHintForDock(docks[QInternal::TopDock]);
     if (top_hint.isNull() || fallbackToSizeHints)
         top_hint = docks[QInternal::TopDock].sizeHint();
     QSize top_min = docks[QInternal::TopDock].minimumSize();
     QSize top_max = docks[QInternal::TopDock].maximumSize();
     top_hint = top_hint.boundedTo(top_max).expandedTo(top_min);
 
-    QSize bottom_hint = docks[QInternal::BottomDock].size();
+    QSize bottom_hint = sizeHintForDock(docks[QInternal::BottomDock]);
     if (bottom_hint.isNull() || fallbackToSizeHints)
         bottom_hint = docks[QInternal::BottomDock].sizeHint();
     QSize bottom_min = docks[QInternal::BottomDock].minimumSize();
@@ -3270,6 +3291,10 @@
     int delta = 0;
     int index = separator.last();
 
+    for (int i = 0; i < QInternal::DockCount; ++i)
+        if (!docks[i].restoredSizeHint.isNull())
+            docks[i].restoredSizeHint = QSize(0, 0);
+
     if (separator.count() > 1) {
         QDockAreaLayoutInfo *info = this->info(separator);
         delta = pick(info->o, dest - origin);
--- qtbase/src/widgets/widgets/qdockarealayout_p.h.orig	2019-12-01 12:05:53.000000000 -0500
+++ qtbase/src/widgets/widgets/qdockarealayout_p.h	2019-12-01 12:06:05.000000000 -0500
@@ -190,6 +190,7 @@
 
     QMainWindowLayout *mainWindowLayout() const;
 
+    QSize restoredSizeHint;
     const int *sep;
     mutable QVector<QWidget*> separatorWidgets;
     QInternal::DockPosition dockPos;
